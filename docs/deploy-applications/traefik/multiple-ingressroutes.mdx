---
id: traefik-multiple-ingressroutes
title: Multiple IngressRoutes
---

# Multiple IngressRoutes for One App

Create multiple IngressRoutes to expose the same service under different subdomains â€” for example, an API endpoint and a web frontend endpoint.

## Prerequisites

**`base/base-values.yaml`**
```yaml
image:
  registry: docker.io
  repository: traefik/whoami
  tag: latest
  port: 80
```

## Configuration

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="list" label="customResources (list)">

**`envs/prod/values.yaml`**
```yaml
deployment:
  enabled: true
  replicas: 1

service:
  enabled: true

customResources:
  - |
    apiVersion: traefik.io/v1alpha1
    kind: IngressRoute
    metadata:
      name: my-app-api-prod
      annotations:
        kubernetes.io/ingress.class: public-traefik
        external-dns.alpha.kubernetes.io/target: public-v2.{{ .Values.captain_domain }}
    spec:
      entryPoints:
        - web
        - websecure
      routes:
        - match: Host(`my-app-api-prod.apps.{{ .Values.captain_domain }}`)
          kind: Rule
          services:
            - name: '{{ include "app.name" . }}'
              namespace: '{{ include "app.namespace" . }}'
              port: 80
  - |
    apiVersion: traefik.io/v1alpha1
    kind: IngressRoute
    metadata:
      name: my-app-web-prod
      annotations:
        kubernetes.io/ingress.class: public-traefik
        external-dns.alpha.kubernetes.io/target: public-v2.{{ .Values.captain_domain }}
    spec:
      entryPoints:
        - web
        - websecure
      routes:
        - match: Host(`my-app-web-prod.apps.{{ .Values.captain_domain }}`)
          kind: Rule
          services:
            - name: '{{ include "app.name" . }}'
              namespace: '{{ include "app.namespace" . }}'
              port: 80
```

</TabItem>
<TabItem value="map" label="customResourcesMap (map)">

**`envs/prod/values.yaml`**
```yaml
deployment:
  enabled: true
  replicas: 1

service:
  enabled: true

customResourcesMap:
  api-route: |
    apiVersion: traefik.io/v1alpha1
    kind: IngressRoute
    metadata:
      name: my-app-api-prod
      annotations:
        kubernetes.io/ingress.class: public-traefik
        external-dns.alpha.kubernetes.io/target: public-v2.{{ .Values.captain_domain }}
    spec:
      entryPoints:
        - web
        - websecure
      routes:
        - match: Host(`my-app-api-prod.apps.{{ .Values.captain_domain }}`)
          kind: Rule
          services:
            - name: '{{ include "app.name" . }}'
              namespace: '{{ include "app.namespace" . }}'
              port: 80
  web-route: |
    apiVersion: traefik.io/v1alpha1
    kind: IngressRoute
    metadata:
      name: my-app-web-prod
      annotations:
        kubernetes.io/ingress.class: public-traefik
        external-dns.alpha.kubernetes.io/target: public-v2.{{ .Values.captain_domain }}
    spec:
      entryPoints:
        - web
        - websecure
      routes:
        - match: Host(`my-app-web-prod.apps.{{ .Values.captain_domain }}`)
          kind: Rule
          services:
            - name: '{{ include "app.name" . }}'
              namespace: '{{ include "app.namespace" . }}'
              port: 80
```

:::tip
Using `customResourcesMap` here makes it easy to add or remove routes per environment. For example, you could define the API route in `base-values.yaml` and add the web route only in `envs/prod/values.yaml`.
:::

</TabItem>
</Tabs>

## What Gets Created

| Resource | Name | Hostname |
|----------|------|----------|
| IngressRoute | `my-app-api-prod` | <code>my-app-api-prod.apps.<CaptainDomain /></code> |
| IngressRoute | `my-app-web-prod` | <code>my-app-web-prod.apps.<CaptainDomain /></code> |

Both route to the same `my-app-prod` service.

## Verify

```bash
# Both hostnames should resolve (after ~2 min for DNS)
curl https://my-app-api-prod.apps.CAPTAIN_DOMAIN
curl https://my-app-web-prod.apps.CAPTAIN_DOMAIN
```

:::note
The `-prod` suffix matches your environment folder name (`envs/prod/`). If you deploy to a different environment like `envs/uat/`, the suffix changes accordingly (e.g., `my-app-api-uat`).
:::

## Key Points

- Each IngressRoute must have a **unique `metadata.name`** within the namespace
- Both IngressRoutes need their own `external-dns` annotation so DNS records are created for each hostname
- You can attach different middlewares to each IngressRoute (e.g., rate limiting on the API, different headers on the web route)
